public class Lesson7 {

    static int[][] graf =
            {{0,1,1,0,0,0},
             {1,0,0,1,1,0},
             {1,0,0,1,0,5},
             {0,1,1,0,1,1},
             {0,1,0,1,0,1},
             {0,0,1,1,1,0}};

    static int[] arr = new int[graf.length];


    public static void main(String[] args) {
//  6. Переписать программу алгоритма Дейкстры на свой язык программирования

//        dekstra();

//  3. Написать функцию обхода графа в ширину.

        for (int i = 0; i < graf.length; i++) {
            arr[i] = 0;
        }

        grafFunkShir(0);

    }

    private static void grafFunkShir(int peak) {
        System.out.println("Посещаем вершину: "+peak);
        arr[peak] = 1;
        for (int i = 0; i < graf.length; i++) {
            if (graf[peak][i] != 0 && arr[i] != 1){

                grafFunkShir(i);
            }
        }



    }
//Алгоритм пока не работает, так и не разобрался до конца   :`-(((
    private static void dekstra() {
//        Размер матрицы весов
        final int N = 5;
//        Матрица весов,  инициализация
        int[][] W = {{1000, 2, 5, 1000, 7},
                {2, 1000, 1, 1000, 1000},
                {5, 1, 1000, 5, 1},
                {1000, 1000, 5, 1000, 3},
                {7, 1000, 1, 3, 1000}};
//        Активные вершины
        int[] active = {0, 0, 0, 0, 0};
//        Вес пути из вершины
        int[] Route = new int[N];
//        Вершина из которой мы приезжаем
        int[] Peak = new int[N];
//        мин - минимальное расстояние до ближайшей вершины
        int min;
//        минимальное расстояние чтобы добраться до вершины
        int kMin = 0;
//        максимальное число интовое
        final int MAXINT = 1000;
//        минимальное расстояние
        min = MAXINT;
//        Инициализируем вершины уникальными числами(типо красим)
//                       Веса из вершины 0 к остальным
//                       Помечаем вершины из которой нужно приехать как -1, типо не из какой
        for (int i = 0; i < N; i++) {
            active[i] = 1;
//            Route[i] = W[0][i];
            Peak[i] = -1;
        }
//        Выбираем первую вершину, это 0
        active[0] = 0;
//        Начинаем цикл обработки вершин с нулевой вершины
//        из неё проверяем путь до остальных
        for (int j = 0; j < N - 1; j++) {

//            active[j] = 0;

            for (int i = 0; i < N; i++) {
//                active[j] = 1;
//                Заполняем веса из нашей вершины до других
                Route[i] = W[j][i];
            }

//        Находим ближайшую вершину

            for (int i = 0; i < N; i++) {
                if (active[i] == 1 && Route[i] < min) {
//              Если пришли сюда, значит пока этот вес минимальный
//                    мин = минимальному весу
                    min = Route[i];
//                    кМин = вершине к которой вес минимален
                    kMin = i;

                }
            }
//            помечаем ближайшую вершину 0, типо мы её отработали?
            active[kMin] = 0;
//
            Peak[j] = kMin;
//        Проверяем есть ли пути к нашей вершине короче,
//        сравниваем записанный вес и сумму минимального пути из найденной вершины и путь между ними.
            for (int i = 0; i < N; i++) {

                if (Route[i] > Route[kMin] + W[kMin][i] && W[kMin][i] != MAXINT) {
                    Route[i] = Route[kMin] + W[kMin][i];
                    Peak[i] = kMin;
                }
            }
        }
//        Переходим к следующей вершине в цикле, поидеи

//        **********************************************

//        Печатаем самый короткий путь из массива вершин
  /*      int i = N - 1;
        while (i != -1) {
            System.out.println(i);
            i = Peak[i];
        }
*/
        for (int i = 0; i < N; i++) {
            System.out.println(Peak[i]);
        }
    }

}
