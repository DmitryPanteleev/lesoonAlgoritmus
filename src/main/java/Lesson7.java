public class Lesson7 {

    public static void main(String[] args) {
//  6. Переписать программу алгоритма Дейкстры на свой язык программирования

        dekstra();

    }

    private static void dekstra() {
//        Размер матрицы весов
        final int N = 5;
//        Матрица весов,  инициализация
        int[][] W = {{1000, 2, 5, 1000, 7},
                {2, 1000, 1, 1000, 1000},
                {5, 1, 1000, 5, 1},
                {1000, 1000, 5, 1000, 3},
                {7, 1000, 1, 3, 1000}};
//        Активные вершины
        int[] active = {0, 0, 0, 0, 0};
//        Вес пути из вершины
        int[] Route = new int[N];
//        Вершина из которой мы приезжаем
        int[] Peak = new int[N];
//        мин - минимальное расстояние до ближайшей вершины
        int min;
//        минимальное расстояние чтобы добраться до вершины
        int kMin = 0;
//        максимальное число интовое
        final int MAXINT = 2147483647;
//        минимальное расстояние
        min = MAXINT;
//        Инициализируем вершины уникальными числами(типо красим)
//        Веса из вершины 0 к остальным
//        Помечаем вершины из которой нужно приехать как -1, типо не из какой
        for (int i = 0; i < N; i++) {
            active[i] = 1;
            Route[i] = W[0][i];
            Peak[i] = -1;
        }
//        Выбираем первую вершину, это 0
        active[0] = 0;
//
        for (int j = 0; j <N-1 ; j++) {

//        Находим ближайшую вершину
            for (int i = 0; i < N; i++) {
                if (active[i] == 1 && Route[i] < min) {
//              Если пришли сюда, значит пока этот вес минимальный
//                    мин = минимальному весу
                    min = Route[i];
//                    кМин = вершине к которой вес минимален
                    kMin = i;
                }
            }
//            помечаем ближайшую вершину 0, типо мы её отработали?
            active[kMin] = 0;
//        Проверяем есть ли пути к нашей вершине короче,
//        сравниваем записанный вес и сумму минимального веса и веса прямого пути до элемента из таблиы весов
            for (int i = 0; i < N; i++) {
                if (Route[i] > Route[kMin] + W[i][kMin] && W[i][kMin] != MAXINT) {
                    Route[i] = Route[kMin] + W[i][kMin];
                    Peak[i] = kMin;
                }
            }
        }
//        Переходим к следующей вершине в цикле, поидеи

//        **********************************************

//        Печатаем самый короткий путь из массива вершин
        int i = N - 1;
        while (i!=-1){
            System.out.println(i);
            i = Peak[i];
        }

    }

}
